# frozen_string_literal: true

default_platform(:ios)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# HELPER METHODS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def setup_api_key
  # Use App Store Connect API key for authentication (recommended for CI/CD)
  if ENV["APP_STORE_CONNECT_API_KEY_CONTENT"]
    app_store_connect_api_key(
      key_id: ENV["APP_STORE_CONNECT_API_KEY_ID"],
      issuer_id: ENV["APP_STORE_CONNECT_API_ISSUER_ID"],
      key_content: ENV["APP_STORE_CONNECT_API_KEY_CONTENT"],
      is_key_content_base64: true,
      in_house: false
    )
  end
end

def notify_success(lane_name, message)
  if ENV["SLACK_WEBHOOK_URL"]
    slack(
      message: "âœ… #{lane_name}: #{message}",
      success: true,
      slack_url: ENV["SLACK_WEBHOOK_URL"]
    )
  end
  UI.success("#{lane_name}: #{message}")
end

def notify_failure(lane_name, exception)
  if ENV["SLACK_WEBHOOK_URL"]
    slack(
      message: "âŒ #{lane_name} failed: #{exception.message}",
      success: false,
      slack_url: ENV["SLACK_WEBHOOK_URL"]
    )
  end
  UI.error("#{lane_name} failed: #{exception.message}")
end

platform :ios do
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SETUP & CERTIFICATES
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  desc "Sync development certificates and profiles"
  lane :sync_dev_certs do
    match(
      type: "development",
      readonly: is_ci
    )
  end

  desc "Sync App Store certificates and profiles"
  lane :sync_appstore_certs do
    match(
      type: "appstore",
      readonly: is_ci
    )
  end

  desc "Register new devices from a file"
  lane :register_devices_from_file do
    register_devices(devices_file: "./fastlane/devices.txt")
    match(type: "development", force_for_new_devices: true)
  end

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # VERSION MANAGEMENT
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  desc "Increment build number"
  lane :increment_build do
    increment_build_number(
      build_number: ENV["BUILD_NUMBER"] || (latest_testflight_build_number + 1)
    )
    build = get_build_number
    UI.success("Build number incremented to #{build}")
  end

  desc "Set version number"
  lane :set_version do |options|
    version = options[:version]
    if version
      increment_version_number(version_number: version)
      UI.success("Version set to #{version}")
    else
      UI.user_error!("Please provide version parameter: fastlane set_version version:1.2.3")
    end
  end

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # BUILD LANES
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  desc "Build the app for App Store distribution"
  lane :build_release do
    setup_ci if ENV['CI']
    setup_api_key

    sync_appstore_certs

    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      export_method: "app-store",
      output_directory: "./build",
      output_name: "RideLink.ipa",
      clean: true,
      include_symbols: true,
      include_bitcode: false
    )
  end

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # TESTFLIGHT DEPLOYMENT
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  desc "Push a new beta build to TestFlight"
  lane :beta do
    begin
      setup_ci if ENV['CI']
      setup_api_key

      sync_appstore_certs

      # Increment build number for TestFlight
      increment_build if ENV['CI']

      build_app(
        workspace: "Runner.xcworkspace",
        scheme: "Runner",
        export_method: "app-store",
        clean: true
      )

      upload_to_testflight(
        skip_waiting_for_build_processing: true,
        distribute_external: false,
        notify_external_testers: false,
        changelog: ENV["CHANGELOG"] || "Bug fixes and improvements"
      )

      notify_success("TestFlight", "Build #{get_build_number} uploaded successfully!")
    rescue => exception
      notify_failure("TestFlight", exception)
      raise exception
    end
  end

  desc "Distribute TestFlight build to external testers"
  lane :distribute_beta do |options|
    setup_api_key

    upload_to_testflight(
      skip_submission: true,
      distribute_external: true,
      notify_external_testers: true,
      groups: options[:groups] || ["Beta Testers"],
      changelog: options[:changelog] || "Bug fixes and improvements"
    )
  end

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # APP STORE DEPLOYMENT
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  desc "Deploy to App Store"
  lane :release do |options|
    begin
      setup_ci if ENV['CI']
      setup_api_key

      sync_appstore_certs

      # Increment build number
      increment_build if ENV['CI']

      build_app(
        workspace: "Runner.xcworkspace",
        scheme: "Runner",
        export_method: "app-store",
        clean: true
      )

      upload_to_app_store(
        submit_for_review: options[:submit] != false,
        automatic_release: options[:auto_release] != false,
        force: true,
        skip_metadata: options[:skip_metadata] || false,
        skip_screenshots: options[:skip_screenshots] || true,
        precheck_include_in_app_purchases: false,
        submission_information: {
          add_id_info_uses_idfa: false,
          export_compliance_uses_encryption: false,
          export_compliance_encryption_updated: false
        }
      )

      version = get_version_number
      build = get_build_number
      notify_success("App Store", "Version #{version} (#{build}) submitted successfully!")
    rescue => exception
      notify_failure("App Store", exception)
      raise exception
    end
  end

  desc "Upload metadata and screenshots only (no binary)"
  lane :upload_metadata do
    setup_api_key

    upload_to_app_store(
      skip_binary_upload: true,
      skip_screenshots: false,
      force: true
    )
  end

  desc "Download existing metadata from App Store Connect"
  lane :download_metadata do
    setup_api_key

    download_metadata(
      output_directory: "./fastlane/metadata"
    )
  end

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # UTILITY LANES
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  desc "Run pre-submission checks"
  lane :precheck_app do
    setup_api_key
    precheck
  end

  desc "Take screenshots for all device sizes"
  lane :screenshots do
    capture_screenshots(
      workspace: "Runner.xcworkspace",
      scheme: "Runner"
    )
    frame_screenshots(
      white: true,
      path: "./fastlane/screenshots"
    )
  end

  desc "Print current version and build number"
  lane :version_info do
    version = get_version_number
    build = get_build_number
    UI.success("Current version: #{version} (#{build})")
  end

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # ERROR HANDLING
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  error do |lane, exception|
    UI.error("Error in lane #{lane}: #{exception.message}")
    
    if ENV["SLACK_WEBHOOK_URL"]
      slack(
        message: "ðŸš¨ Fastlane error in #{lane}",
        success: false,
        payload: {
          "Error" => exception.message,
          "Lane" => lane.to_s
        },
        slack_url: ENV["SLACK_WEBHOOK_URL"]
      )
    end
  end
end
